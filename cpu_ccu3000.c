/* ferguson-srb1-emu                                                     */
/*=======================================================================*/
/* Copyright 2023 Philip Heron <phil@sanslogic.co.uk>                    */
/*                                                                       */
/* This program is free software: you can redistribute it and/or modify  */
/* it under the terms of the GNU General Public License as published by  */
/* the Free Software Foundation, either version 3 of the License, or     */
/* (at your option) any later version.                                   */
/*                                                                       */
/* This program is distributed in the hope that it will be useful,       */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of        */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
/* GNU General Public License for more details.                          */
/*                                                                       */
/* You should have received a copy of the GNU General Public License     */
/* along with this program.  If not, see <http://www.gnu.org/licenses/>. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cpu_ccu3000.h"

#if 0
static const char *_ccu_io_descriptions[0x100] = {
	[0x00] = "Clock frequency",
	[0x01] = "Control register",
	[0x02] = "Watchdog",
	[0x03] = "Port 1 Data",
	[0x04] = "Direction Register Port 1",
	[0x05] = "Port 2 Data",
	[0x06] = "Direction Register Port 2",
	[0x07] = "Port 3 Data",
	[0x08] = "Direction Register Port 3",
	[0x09] = "Port 4 Data",
	[0x0A] = "Port 5 Mode Register",
	[0x0B] = "Port 5 Direction Register",
	[0x0C] = "Port 5 Data",
	[0x0D] = "IR-Input",
	[0x0F] = "Port 7 Mode Register",
	[0x10] = "IM-Bus 1 control and status",
	[0x11] = "IM-Bus 1 data transfer rate",
	[0x13] = "IM-Bus 1 master address",
	[0x14] = "IM-Bus 1 master data low byte",
	[0x15] = "IM-Bus 1 master data high byte",
	[0x16] = "IM-Bus 1 slave 1, IM address 02",
	[0x18] = "IM-Bus 1 slave 2, IM-Bus address 03",
	[0x1A] = "IM-Bus 1 slave 3, IM-Bus address 04",
	[0x1C] = "Interrupt controller control byte",
	[0x1D] = "Interrupt controller return byte",
	[0x1E] = "Interrupt controller priorities source 0 & 1",
	[0x1F] = "Interrupt controller priorities source 2 & 3",
	[0x20] = "Interrupt controller priorities source 4 & 5",
	[0x21] = "Interrupt controller priorities source 6 & 7",
	[0x22] = "Timer 1 control byte 1",
	[0x23] = "Timer 1 control byte 2",
	[0x24] = "Timer 1 control byte 3",
	[0x25] = "Timer 1 prescaler low byte",
	[0x26] = "Timer 1 prescaler high byte",
	[0x28] = "Timer 1 accu low byte",
	[0x29] = "Timer 1 accu high byte",
	[0x2A] = "Timer 1 adder low byte",
	[0x2B] = "Timer 1 adder high byte",
	[0x2C] = "Timer 2 control byte 1",
	[0x2D] = "Timer 2 control byte 2",
	[0x2E] = "Timer 2 control byte 3",
	[0x2F] = "Timer 2 prescaler low byte",
	[0x30] = "Timer 2 prescaler high byte",
	[0x32] = "Timer 2 accu low byte",
	[0x33] = "Timer 2 accu high byte",
	[0x34] = "Timer 2 adder low byte",
	[0x35] = "Timer 2 adder high byte",
	[0x36] = "Timer 3 control byte 1",
	[0x37] = "Timer 3 control byte 2",
	[0x38] = "Timer 3 control byte 3",
	[0x39] = "Timer 3 prescaler low byte",
	[0x3A] = "Timer 3 prescaler high byte",
	[0x3C] = "Timer 3 accu low byte",
	[0x3D] = "Timer 3 accu high byte",
	[0x3E] = "Timer 3 adder low byte",
	[0x3F] = "Timer 3 adder high byte",
	[0x40] = "Port 6 Data",
	[0x41] = "Direction Register Port 6",
	[0x42] = "Port 7 Data",
	[0x43] = "Direction Register Port 7",
	[0x44] = "Port 8 Data",
	[0x45] = "Direction Register Port 8",
	[0x46] = "IM-Bus 2 control & status",
	[0x47] = "IM-Bus 2 transfer rate",
	[0x49] = "IM-Bus 2 master address",
	[0x4A] = "IM-Bus 2 master data low",
	[0x4B] = "IM-bus 2 master data high",
	[0x4C] = "IM-bus 2 slave 1, IM address 02",
	[0x4E] = "IM-bus 2 slave 2, IM address 03",
	[0x50] = "IM-bus 2 slave 3, IM address 04",
	[0xE0] = "External addresse 2E0H, used for EMU boards",
	[0xE1] = "External addresse 2E1H, used for EMU boards",
	[0xE2] = "External addresse 2E2H, used for EMU boards",
	[0xE3] = "External addresse 2E3H, used for EMU boards",
	[0xE4] = "External addresse 2E4H, used for EMU boards",
	[0xE5] = "External addresse 2E5H, used for EMU boards",
	[0xE6] = "External addresse 2E6H, used for EMU boards",
	[0xE7] = "External addresse 2E7H, used for EMU boards",
	[0xFE] = "Reserved, do not use",
	[0xFF] = "Reserved for testing purposes",
};
#endif

static uint8_t _ccu_io_read(struct cpu_ccu3000_t *s, uint16_t addr)
{
	//const char *desc = _ccu_io_descriptions[addr & 0xFF];
	uint8_t v = 0x00;
	
	//printf("ccuio:  Read $%03X: %s\n", addr, desc ? desc : "invalid");
	
	switch(addr)
	{
	case 0x202:
		v = 1 << 0; /* '0': last RESET was generated by watchdog */
		break;
	
	case 0x20C:
		//printf("Port 5 data: OUT: %02X, IN: %02X, DDR: %02X\n", s->p5_data, s->p5_data_in, s->p5_ddr);
		v = (s->p5_data_in &  (s->p5_ddr | s->p5_data)) |
		    (s->p5_data    & ~(s->p5_ddr | s->p5_data));
		//printf("Port 5 read: %02X\n", v);
		break;
	
	case 0x210:
		v = 0 << 0; /* '1' = IM bus (master) busy */
		break;
	
	case 0x23E:
		//v = s->timer3_adder_low++;
		break;
	
	case 0x240:
		//printf("Port 6: OUT: %02X, IN: %02X, DDR: %02X\n", s->p6_data, s->p6_data_in, s->p6_ddr);
		v = (s->p6_data_in &  (s->p6_ddr | s->p6_data)) |
		    (s->p6_data    & ~(s->p6_ddr | s->p6_data));
		break;
	
	case 0x242:
		v = (s->p7_data_in &  (s->p7_ddr | s->p7_data)) |
		    (s->p7_data    & ~(s->p7_ddr | s->p7_data));
		break;
	
	case 0x244:
		//printf("Port 8: OUT: %02X, IN: %02X, DDR: %02X\n", s->p8_data, s->p8_data_in, s->p8_ddr);
		v = (s->p8_data_in &  (s->p8_ddr | s->p8_data)) |
		    (s->p8_data    & ~(s->p8_ddr | s->p8_data));
		break;
	
	case 0x246:
		v = 0 << 0; /* '1' = IM bus (master) busy */
		break;
	}
	
	return(v);
}

static void _i2c_test(struct cpu_ccu3000_t *s)
{
	static uint8_t pv = 0x03;
	static uint8_t sr = 0;
	static uint8_t b = 0;
	uint8_t v;
	
	/* Read the I2C bus status */
	v = (s->p5_data_in &  (s->p5_ddr | s->p5_data)) |
	    (s->p5_data    & ~(s->p5_ddr | s->p5_data));
	v &= 0x03;
	
	if(v != pv)
	{
		//printf("i2c: Clock: %d, Data: %d, b: %d\n", v & 2 ? 1 : 0, v & 1, b);
	}
	
	if(pv == 3 && v == 2)
	{
		/* Rising data edge while clock high */
		printf("i2c: start\n");
		b = 0;
		sr = 0;
	}
	else if(pv == 2 && v == 3)
	{
		/* Falling data edge while clock high */
		printf("i2c: end\n");
		b = 0;
		sr = 0;
	}
	//else if(!(pv & 2) && (v & 2))
	//{
	//	/* Rising clock edge (data low or high) */
	//	//printf("i2c: bit %d\n", v & 1);
	//}
	else if((pv & 2) && !(v & 2))
	{
		/* Falling clock edge (data low or high) */
		
		if(b > 0 && b <= 8)
		{
			//printf("i2c: bit %d\n", v & 1);
			sr = (sr << 1) | (v & 1);
		}
		
		if(b == 8)
		{
			printf("i2c: byte 0x%02X\n", sr);
			
			/* ACK */
			//printf("i2c: asserting ACK\n");
			s->p5_data_in &= ~1;
		}
		else if((s->p5_data_in & 1) == 0)
		{
			//printf("i2c: releasing ACK\n");
			s->p5_data_in |= 1;
		}
		
		if(b == 9)
		{
			b = 0;
		}
		
		b++;
	}
	
	pv = v;
}

static void _timer_dump(struct cpu_ccu3000_t *s, int timer, int cbyte)
{
	printf("timer%d:\n", timer + 1);
	
	if(cbyte == 0)
	{
		const char *clocks[4] = { "pin", "fosc", "PHI2", "no clock" };
		const char *start[4] = { "none (always active)", "edge", "pin", "\\pin" };
		
		printf("1:7: second serial input level: %s\n", s->timer[timer].ctrl[0] & 0x80 ? "enabled" : "disabled");
		printf("1:5-6: clock select: %s\n", clocks[(s->timer[timer].ctrl[0] >> 5) & 3]);
		printf("1:4: counter stop: %s\n", s->timer[timer].ctrl[0] & 0x10 ? "carry out accu" : "disabled");
		printf("1:1-2: start condition: %s\n", start[(s->timer[timer].ctrl[0] >> 1) & 3]);
		printf("1:0: active edge selection: %s\n", s->timer[timer].ctrl[0] & 1 ? "falling" : "rising");
	}
	else if(cbyte == 1)
	{
		const char *modes[4] = { "disabled", "serial out", "PWM", "carry accu D" };
		const char *latch[8] = { "disabled", "carry accu C", "carry accu D", "pin", "\\pin", "prescaler output", "prescaler input", "undefined" };
		const char *clock[4] = { "presc. input", "pre.output", "pin", "\\pin" };
		
		printf("2:6-7: pin output mode: %s\n", modes[(s->timer[timer].ctrl[1] >> 6) & 3]);
		printf("2:3-5: read latch: %s\n", latch[(s->timer[timer].ctrl[1] >> 3) & 7]);
		printf("2:1-2: accu clock: %s\n", clock[(s->timer[timer].ctrl[1] >> 1) & 3]);
		printf("2:0: %s\n", s->timer[timer].ctrl[1] & 1 ? "use accu c with accu d as long one (16bit accu)" : "don't use accu c with accu d as long one (16bit accu)");
	}
	else if(cbyte == 2)
	{
		const char *event[8] = { "none", "pin", "\\pin", "carry accu C", "carry accu D", "undefined", "undefined", "undefined" };
		const char *levent[4] = { "none", "carry accu C", "carry accu D", "reg. load" };
		
		printf("3:5-7: interrupt event: %s\n", event[(s->timer[timer].ctrl[2] >> 5) & 7]);
		printf("3:3-4: load event: %s\n", levent[(s->timer[timer].ctrl[2] >> 3) & 3]);
		printf("3:2: accu C input: %s\n", s->timer[timer].ctrl[2] & 0x04 ? "-1" : "bus register");
		printf("3:1: accu D input: %s\n", s->timer[timer].ctrl[2] & 0x02 ? "-1" : "bus register");
		printf("3:0: serial mode: %s\n", s->timer[timer].ctrl[2] & 0x01 ? "enabled" : "disabled");
	}
}

static void _ccu_io_write(struct cpu_ccu3000_t *s, uint16_t addr, uint8_t v)
{
	//const char *desc = _ccu_io_descriptions[addr & 0xFF];
	
	//printf("ccuio: Write $%03X = $%02X: %s\n", addr, v, desc ? desc : "invalid");
	
	switch(addr)
	{
	case 0x20B:
		s->p5_ddr = v;
		break;
	
	case 0x20C:
		s->p5_data = v;
		
		_i2c_test(s);
		
		break;
	
	case 0x21C: /* Interrupt controller control byte */
		s->irq_enabled = ((v & (1 << 2)) ? 1 : 0);
		break;
	
	case 0x222: /* Timer 1 control bytes */
	case 0x223:
	case 0x224:
		s->timer[0].ctrl[addr - 0x222] = v;
		_timer_dump(s, 0, addr - 0x222);
		break;
	
	case 0x225: /* Timer 1 prescaler low byte */
		s->timer[0].prescaler = (s->timer[0].prescaler & 0xFF00) | v;
		break;
	
	case 0x226: /* Timer 1 prescaler high byte */
		s->timer[0].prescaler = (s->timer[0].prescaler & 0x00FF) | (v << 8);
		break;
	
	case 0x228: /* Timer 1 accu low byte */
		s->timer[0].accu = (s->timer[0].accu & 0xFF00) | v;
		break;
	
	case 0x229: /* Timer 1 accu high byte */
		s->timer[0].accu = (s->timer[0].accu & 0x00FF) | (v << 8);
		break;
	
	case 0x22A: /* Timer 1 adder low byte */
		s->timer[0].adder = (s->timer[0].adder & 0xFF00) | v;
		break;
	
	case 0x22B: /* Timer 1 adder high byte */
		s->timer[0].adder = (s->timer[0].adder & 0x00FF) | (v << 8);
		break;
	
	case 0x22C: /* Timer 2 control bytes */
	case 0x22D:
	case 0x22E:
		s->timer[1].ctrl[addr - 0x22C] = v;
		_timer_dump(s, 1, addr - 0x22C);
		break;
	
	case 0x22F: /* Timer 2 prescaler low byte */
		s->timer[1].prescaler = (s->timer[1].prescaler & 0xFF00) | v;
		break;
	
	case 0x230: /* Timer 2 prescaler high byte */
		s->timer[1].prescaler = (s->timer[1].prescaler & 0x00FF) | (v << 8);
		break;
	
	case 0x232: /* Timer 2 accu low byte */
		s->timer[1].accu = (s->timer[1].accu & 0xFF00) | v;
		break;
	
	case 0x233: /* Timer 2 accu high byte */
		s->timer[1].accu = (s->timer[1].accu & 0x00FF) | (v << 8);
		break;
	
	case 0x234: /* Timer 2 adder low byte */
		s->timer[1].adder = (s->timer[1].adder & 0xFF00) | v;
		break;
	
	case 0x235: /* Timer 2 adder high byte */
		s->timer[1].adder = (s->timer[1].adder & 0x00FF) | (v << 8);
		break;
	
	case 0x236: /* Timer 3 control bytes */
	case 0x237:
	case 0x238:
		s->timer[2].ctrl[addr - 0x236] = v;
		_timer_dump(s, 2, addr - 0x236);
		break;
	
	case 0x239: /* Timer 3 prescaler low byte */
		s->timer[2].prescaler = (s->timer[2].prescaler & 0xFF00) | v;
		break;
	
	case 0x23A: /* Timer 3 prescaler high byte */
		s->timer[2].prescaler = (s->timer[2].prescaler & 0x00FF) | (v << 8);
		break;
	
	case 0x23C: /* Timer 3 accu low byte */
		s->timer[2].accu = (s->timer[2].accu & 0xFF00) | v;
		break;
	
	case 0x23D: /* Timer 3 accu high byte */
		s->timer[2].accu = (s->timer[2].accu & 0x00FF) | (v << 8);
		break;
	
	case 0x23E: /* Timer 3 adder low byte */
		s->timer[2].adder = (s->timer[2].adder & 0xFF00) | v;
		break;
	
	case 0x23F: /* Timer 3 adder high byte */
		s->timer[2].adder = (s->timer[2].adder & 0x00FF) | (v << 8);
		break;
	
	case 0x240:
		s->p6_data = v;
		break;
	
	case 0x241:
		s->p6_ddr = v;
		break;
	
	case 0x242:
		s->p7_data = v;
		break;
	
	case 0x243:
		s->p7_ddr = v;
		break;
	
	case 0x244:
		s->p8_data = v;
		break;
	
	case 0x245:
		s->p8_ddr = v;
		break;
	}
}

static uint8_t _ccu_memory_read(void *private, uint16_t addr)
{
	struct cpu_ccu3000_t *s = private;
	
	if(addr >= 0x200 && addr < 0x300)
	{
		return(_ccu_io_read(s, addr));
	}
	else if(addr < 0x0640)
	{
		/* Reading from internal RAM */
		return(s->ram[addr]);
	}
	else if(s->ext)
	{
		return(s->ext->read(s->ext->private, addr));
	}
	
	return(0xFF);
}

static void _ccu_memory_write(void *private, uint16_t addr, uint8_t v)
{
	struct cpu_ccu3000_t *s = private;
	
	if(addr >= 0x200 && addr < 0x300)
	{
		_ccu_io_write(s, addr, v);
	}
	else if(addr < 0x0640)
	{
		/* Writing to internal RAM */
		s->ram[addr] = v;
	}
	else if(s->ext)
	{
		s->ext->write(s->ext->private, addr, v);
	}
}

static int _ccu_memory_init(struct cpu_memory_t *mem, struct cpu_ccu3000_t *s)
{
	s->ram = malloc(0x0640);
	if(!s->ram)
	{
		return(-1);
	}
	
	mem->private = s;
	mem->read = &_ccu_memory_read;
	mem->write = &_ccu_memory_write;
	
	return(0);
}

void cpu_ccu3000_init(struct cpu_ccu3000_t *s, int clock_num, int clock_den, struct cpu_memory_t *mem)
{
	memset(s, 0, sizeof(struct cpu_ccu3000_t));
	
	s->ext = mem;
	
	_ccu_memory_init(&s->mem, s);
	
	cpu_65c02_init(&s->core, clock_num, clock_den, &s->mem);
}

void cpu_ccu3000_reset(struct cpu_ccu3000_t *s)
{
	cpu_65c02_reset(&s->core);
	
	s->p5_ddr = 0xFF;
	s->p6_ddr = 0xFF;
	s->p7_ddr = 0xFF;
	s->p8_ddr = 0xFF;
}

void cpu_ccu3000_irq_custom(struct cpu_ccu3000_t *s, uint16_t addr, int brk)
{
	cpu_65c02_irq_custom(&s->core, addr, brk);
}

void cpu_ccu3000_irq(struct cpu_ccu3000_t *s, int type)
{
	cpu_65c02_irq(&s->core, type);
}

void cpu_ccu3000_exec(struct cpu_ccu3000_t *s)
{
	cpu_65c02_exec(&s->core);
}

